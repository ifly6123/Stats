<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide: Latin Square Design (LSD)</title>
    <link rel="stylesheet" href="../style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display.swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <nav class="breadcrumb">
        <a href="../index.html">Home</a> &gt;
        <a href="../study-guides.html">Study Guides</a> &gt;
        <span>Latin Square Design (LSD)</span>
    </nav>
    <header class="module-header">
        <h1 class="gradient-text-grey">Latin Square Design (LSD) üß©</h1>
        <p>A "Sudoku" for scientists to control two problems at once.</p>
    </header>

    <main class="guide-content">
        <h2>What is a Latin Square?</h2>
        <p>A <strong>Latin Square Design (LSD)</strong> is a very smart way to set up an experiment when you have <strong>two</strong> different "noise" factors (or gradients) that you need to control.</p>
        <p>Think about our <a href="rbd.html">RBD example</a>. We had one problem: a soil gradient from top to bottom. We used "Blocks" (the rows) to fix it.</p>
        <p>But what if your field has <strong>two</strong> problems? For example:</p>
        <ol>
            <li>A soil gradient from top to bottom (Row effect).</li>
            <li>A sun gradient from left to right (Column effect).</li>
        </ol>

        <p>An RBD can only fix one of those problems. An LSD can fix <strong>both at the same time!</strong></p>

        <h2>The "Sudoku" Rule</h2>
        <p>An LSD works just like a Sudoku puzzle. You must have the same number of rows, columns, and treatments. For example, to test 4 treatments (A, B, C, D), you need a 4x4 grid.</p>
        <p>The rule is: <strong>Each treatment must appear exactly ONCE in each row and ONCE in each column.</strong></p>
        <p>By following this rule, you guarantee that every treatment (A, B, C, D) gets a "fair turn" at every row (soil type) and every column (sun level). This completely isolates the "noise" from both gradients, making your test super precise.</p>

        <hr style="margin: 30px 0;">

        <h2>Interactive: Build a 4x4 Latin Square</h2>
        <p>Try to create a valid 4x4 Latin Square yourself! Fill in the grid below with the letters A, B, C, and D. Remember the rule: <strong>each letter must appear only once in every row and every column.</strong></p>

        <div class="interactive-calc dark-bg">
            <div id="lsd-grid-container">
                <table class="lsd-input-grid">
                    <thead>
                        <tr><th></th><th>Column 1</th><th>Column 2</th><th>Column 3</th><th>Column 4</th></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>Row 1</th>
                            <td><input type="text" class="lsd-input" id="cell-0-0" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-0-1" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-0-2" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-0-3" maxlength="1"></td>
                        </tr>
                        <tr>
                            <th>Row 2</th>
                            <td><input type="text" class="lsd-input" id="cell-1-0" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-1-1" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-1-2" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-1-3" maxlength="1"></td>
                        </tr>
                        <tr>
                            <th>Row 3</th>
                            <td><input type="text" class="lsd-input" id="cell-2-0" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-2-1" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-2-2" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-2-3" maxlength="1"></td>
                        </tr>
                        <tr>
                            <th>Row 4</th>
                            <td><input type="text" class="lsd-input" id="cell-3-0" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-3-1" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-3-2" maxlength="1"></td>
                            <td><input type="text" class="lsd-input" id="cell-3-3" maxlength="1"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="lsd-controls">
                <button class="doe-btn" id="lsd-check-btn">Check My Design</button>
                <button class="doe-btn" id="lsd-fill-btn">Show Me an Example</button>
            </div>
            <div id="lsd-feedback" class="stat-result not-significant">
                <p>Fill in the grid and click "Check My Design".</p>
            </div>
        </div>
        <hr style="margin: 30px 0;">

        <h2>Pros and Cons of LSD</h2>

        <h3>üëç Pros (The Good Stuff)</h3>
        <ul>
            <li><strong>Extremely Powerful:</strong> It's fantastic at removing noise when you have <strong>two</strong> known gradients (like rows and columns).</li>
            <li><strong>Efficient:</strong> You can test 4 treatments with only 16 plots ($4 \times 4$). A full factorial design might need many more.</li>
        </ul>

        <h3>üëé Cons (The Problems)</h3>
        <ul>
            <li><strong>Very Rigid:</strong> The number of treatments *must* equal the number of rows and columns. You can't have 4 treatments in a 5x5 grid.</li>
            <li><strong>Missing Data is a Disaster:</strong> If even *one* plot is lost, the analysis becomes extremely difficult and the design is broken.</li>
            <li><strong>Assumes No Interaction:</strong> The design *assumes* there is no special "interaction" between the row and column effects (e.g., the sun effect is the same for all soil types).</li>
        </ul>
        <p><strong>The takeaway:</strong> LSD is a powerful, efficient design, but only use it when you have two known gradients and you are confident you won't lose any data!</p>

    </main>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function () { renderMathInElement(document.body, { delimiters: [{ left: "$", right: "$", display: false }] }); });</script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            (function setupLSDViz() {
                // Check for D3
                if (typeof d3 === 'undefined') {
                    console.error("D3.js is not loaded! Cannot start visualizer.");
                    document.querySelector("#lsd-grid-container").innerHTML = "<p style='color: red; padding: 10px;'>Error: Visualizer could not be loaded.</p>";
                    return;
                }

                // --- 1. Setup ---
                const k = 4; // 4x4 grid
                const treatments = ['A', 'B', 'C', 'D'];
                const feedbackEl = d3.select("#lsd-feedback");
                const inputs = d3.selectAll(".lsd-input");

                const exampleSquare = [
                    ['A', 'B', 'C', 'D'],
                    ['B', 'C', 'D', 'A'],
                    ['C', 'D', 'A', 'B'],
                    ['D', 'A', 'B', 'C']
                ];

                // --- 2. Helper Functions ---
                function checkSquare() {
                    let grid = [];
                    let isValid = true;
                    let errorMessage = "";

                    // Reset all input styles
                    inputs.classed("error", false);

                    // 1. Read the grid and check for valid entries
                    for (let r = 0; r < k; r++) {
                        let row = [];
                        for (let c = 0; c < k; c++) {
                            const inputEl = d3.select(`#cell-${r}-${c}`);
                            const val = inputEl.property("value").toUpperCase();
                            if (!treatments.includes(val)) {
                                isValid = false;
                                errorMessage = `Found an invalid letter ('${val}') in Row ${r + 1}, Col ${c + 1}. Please use only A, B, C, or D.`;
                                inputEl.classed("error", true);
                                break;
                            }
                            row.push(val);
                        }
                        if (!isValid) break;
                        grid.push(row);
                    }
                    if (!isValid) {
                        setFeedback(errorMessage, "bad");
                        return;
                    }

                    // 2. Check Rows
                    for (let r = 0; r < k; r++) {
                        const rowSet = new Set(grid[r]);
                        if (rowSet.size !== k) {
                            errorMessage = `Row ${r + 1} has a duplicate entry! Each letter must appear once.`;
                            // Highlight the whole row
                            for (let c = 0; c < k; c++) d3.select(`#cell-${r}-${c}`).classed("error", true);
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) {
                        setFeedback(errorMessage, "bad");
                        return;
                    }

                    // 3. Check Columns
                    for (let c = 0; c < k; c++) {
                        let col = [];
                        for (let r = 0; r < k; r++) {
                            col.push(grid[r][c]);
                        }
                        const colSet = new Set(col);
                        if (colSet.size !== k) {
                            errorMessage = `Column ${c + 1} has a duplicate entry! Each letter must appear once.`;
                            // Highlight the whole column
                            for (let r = 0; r < k; r++) d3.select(`#cell-${r}-${c}`).classed("error", true);
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) {
                        setFeedback(errorMessage, "bad");
                        return;
                    }

                    // 4. If we got here, it's valid!
                    setFeedback("Success! üéâ This is a valid Latin Square. You've controlled for both row and column effects!", "good");
                }

                function fillExample() {
                    for (let r = 0; r < k; r++) {
                        for (let c = 0; c < k; c++) {
                            const val = exampleSquare[r][c];
                            d3.select(`#cell-${r}-${c}`)
                                .classed("error", false)
                                .property("value", val);
                        }
                    }
                    setFeedback("Here is one example of a valid Latin Square. Notice how no letter repeats in any row or column.", "good");
                }

                function setFeedback(message, type) {
                    feedbackEl.classed("significant", type === "bad");
                    feedbackEl.classed("not-significant", type === "good");
                    feedbackEl.html(`<p>${message}</p>`);
                }

                // --- 3. Event Listeners ---
                d3.select("#lsd-check-btn").on("click", checkSquare);
                d3.select("#lsd-fill-btn").on("click", fillExample);

                // Auto-uppercase input
                inputs.on("input", function () {
                    this.value = this.value.toUpperCase();
                });

            })();
        });
    </script>

</body>
</html>